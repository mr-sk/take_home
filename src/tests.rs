// THIS FILE WAS GENERATED BY A LLM
// With some tweaking by a human

#[cfg(test)]
mod tests {
    use crate::*;
    use rust_decimal_macros::dec;

    // Helper to create a deposit transaction
    fn make_deposit(client: u16, tx: u32, amount: Decimal) -> TransactionRow {
        TransactionRow {
            tx_type: TransactionType::Deposit,
            client,
            tx,
            amount: Some(amount),
            disputed: false,
        }
    }

    // Helper to create a withdrawal transaction
    fn make_withdrawal(client: u16, tx: u32, amount: Decimal) -> TransactionRow {
        TransactionRow {
            tx_type: TransactionType::Withdrawal,
            client,
            tx,
            amount: Some(amount),
            disputed: false,
        }
    }

    // Helper to create a dispute transaction
    fn make_dispute(client: u16, tx: u32) -> TransactionRow {
        TransactionRow {
            tx_type: TransactionType::Dispute,
            client,
            tx,
            amount: None,
            disputed: false,
        }
    }

    // Helper to create a resolve transaction
    fn make_resolve(client: u16, tx: u32) -> TransactionRow {
        TransactionRow {
            tx_type: TransactionType::Resolve,
            client,
            tx,
            amount: None,
            disputed: false,
        }
    }

    // Helper to create a chargeback transaction
    fn make_chargeback(client: u16, tx: u32) -> TransactionRow {
        TransactionRow {
            tx_type: TransactionType::Chargeback,
            client,
            tx,
            amount: None,
            disputed: false,
        }
    }

    // =========================================================================
    // Deposit Tests
    // =========================================================================

    #[test]
    fn deposit_creates_account_and_adds_funds() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();

        let result = handle_deposit(
            make_deposit(1, 1, dec!(100)),
            &mut accounts,
            &mut transactions,
        );

        assert!(result.is_ok());
        assert_eq!(accounts.get(&1).unwrap().available, dec!(100));
        assert!(transactions.contains_key(&1));
    }

    #[test]
    fn deposit_adds_to_existing_account() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();

        handle_deposit(
            make_deposit(1, 1, dec!(100)),
            &mut accounts,
            &mut transactions,
        )
        .unwrap();
        handle_deposit(
            make_deposit(1, 2, dec!(50)),
            &mut accounts,
            &mut transactions,
        )
        .unwrap();

        assert_eq!(accounts.get(&1).unwrap().available, dec!(150));
    }

    #[test]
    fn deposit_rejects_duplicate_tx_id() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();

        handle_deposit(
            make_deposit(1, 1, dec!(100)),
            &mut accounts,
            &mut transactions,
        )
        .unwrap();
        let result = handle_deposit(
            make_deposit(1, 1, dec!(50)),
            &mut accounts,
            &mut transactions,
        );

        assert!(result.is_err());
        assert_eq!(accounts.get(&1).unwrap().available, dec!(100)); // unchanged
    }

    #[test]
    fn deposit_rejects_zero_amount() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();

        let result = handle_deposit(
            make_deposit(1, 1, dec!(0)),
            &mut accounts,
            &mut transactions,
        );

        assert!(result.is_err());
        assert!(!accounts.contains_key(&1));
    }

    #[test]
    fn deposit_rejects_negative_amount() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();

        let result = handle_deposit(
            make_deposit(1, 1, dec!(-50)),
            &mut accounts,
            &mut transactions,
        );

        assert!(result.is_err());
        assert!(!accounts.contains_key(&1));
    }

    #[test]
    fn deposit_rejects_locked_account() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        accounts.insert(
            1,
            AccountRecord {
                available: dec!(100),
                held: dec!(0),
                locked: true,
            },
        );
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();

        let result = handle_deposit(
            make_deposit(1, 1, dec!(50)),
            &mut accounts,
            &mut transactions,
        );

        assert!(result.is_err());
        assert_eq!(accounts.get(&1).unwrap().available, dec!(100)); // unchanged
    }

    // =========================================================================
    // Withdrawal Tests
    // =========================================================================

    #[test]
    fn withdrawal_subtracts_funds() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        accounts.insert(
            1,
            AccountRecord {
                available: dec!(100),
                held: dec!(0),
                locked: false,
            },
        );

        let tx = make_withdrawal(1, 1, dec!(30));
        let result = handle_withdrawal(&tx, &mut accounts);

        assert!(result.is_ok());
        assert_eq!(accounts.get(&1).unwrap().available, dec!(70));
    }

    #[test]
    fn withdrawal_rejects_insufficient_funds() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        accounts.insert(
            1,
            AccountRecord {
                available: dec!(50),
                held: dec!(0),
                locked: false,
            },
        );

        let tx = make_withdrawal(1, 1, dec!(100));
        let result = handle_withdrawal(&tx, &mut accounts);

        assert!(result.is_err());
        assert_eq!(accounts.get(&1).unwrap().available, dec!(50)); // unchanged
    }

    #[test]
    fn withdrawal_rejects_nonexistent_account() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();

        let tx = make_withdrawal(1, 1, dec!(50));
        let result = handle_withdrawal(&tx, &mut accounts);

        assert!(result.is_err());
    }

    #[test]
    fn withdrawal_rejects_locked_account() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        accounts.insert(
            1,
            AccountRecord {
                available: dec!(100),
                held: dec!(0),
                locked: true,
            },
        );

        let tx = make_withdrawal(1, 1, dec!(30));
        let result = handle_withdrawal(&tx, &mut accounts);

        assert!(result.is_err());
        assert_eq!(accounts.get(&1).unwrap().available, dec!(100)); // unchanged
    }

    #[test]
    fn withdrawal_rejects_zero_amount() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        accounts.insert(
            1,
            AccountRecord {
                available: dec!(100),
                held: dec!(0),
                locked: false,
            },
        );

        let tx = make_withdrawal(1, 1, dec!(0));
        let result = handle_withdrawal(&tx, &mut accounts);

        assert!(result.is_err());
    }

    // =========================================================================
    // Dispute Tests
    // =========================================================================

    #[test]
    fn dispute_moves_funds_to_held() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        accounts.insert(
            1,
            AccountRecord {
                available: dec!(100),
                held: dec!(0),
                locked: false,
            },
        );
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();
        transactions.insert(1, make_deposit(1, 1, dec!(100)));

        let tx = make_dispute(1, 1);
        let result = handle_dispute(&tx, &mut accounts, &mut transactions);

        assert!(result.is_ok());
        assert_eq!(accounts.get(&1).unwrap().available, dec!(0));
        assert_eq!(accounts.get(&1).unwrap().held, dec!(100));
        assert!(transactions.get(&1).unwrap().disputed);
    }

    #[test]
    fn dispute_rejects_nonexistent_transaction() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();

        let tx = make_dispute(1, 999);
        let result = handle_dispute(&tx, &mut accounts, &mut transactions);

        assert!(result.is_err());
    }

    #[test]
    fn dispute_rejects_wrong_client() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        accounts.insert(
            1,
            AccountRecord {
                available: dec!(100),
                held: dec!(0),
                locked: false,
            },
        );
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();
        transactions.insert(1, make_deposit(1, 1, dec!(100)));

        // Client 2 trying to dispute client 1's transaction
        let tx = make_dispute(2, 1);
        let result = handle_dispute(&tx, &mut accounts, &mut transactions);

        assert!(result.is_err());
    }

    #[test]
    fn dispute_rejects_already_disputed() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        accounts.insert(
            1,
            AccountRecord {
                available: dec!(100),
                held: dec!(0),
                locked: false,
            },
        );
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();
        let mut deposit = make_deposit(1, 1, dec!(100));
        deposit.disputed = true;
        transactions.insert(1, deposit);

        let tx = make_dispute(1, 1);
        let result = handle_dispute(&tx, &mut accounts, &mut transactions);

        assert!(result.is_err());
    }

    // =========================================================================
    // Resolve Tests
    // =========================================================================

    #[test]
    fn resolve_moves_funds_back_to_available() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        accounts.insert(
            1,
            AccountRecord {
                available: dec!(0),
                held: dec!(100),
                locked: false,
            },
        );
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();
        let mut deposit = make_deposit(1, 1, dec!(100));
        deposit.disputed = true;
        transactions.insert(1, deposit);

        let tx = make_resolve(1, 1);
        let result = handle_resolve(&tx, &mut accounts, &mut transactions);

        assert!(result.is_ok());
        assert_eq!(accounts.get(&1).unwrap().available, dec!(100));
        assert_eq!(accounts.get(&1).unwrap().held, dec!(0));
        assert!(!transactions.get(&1).unwrap().disputed);
    }

    #[test]
    fn resolve_rejects_not_disputed() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        accounts.insert(
            1,
            AccountRecord {
                available: dec!(100),
                held: dec!(0),
                locked: false,
            },
        );
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();
        transactions.insert(1, make_deposit(1, 1, dec!(100)));

        let tx = make_resolve(1, 1);
        let result = handle_resolve(&tx, &mut accounts, &mut transactions);

        assert!(result.is_err());
    }

    #[test]
    fn resolve_rejects_wrong_client() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        accounts.insert(
            1,
            AccountRecord {
                available: dec!(0),
                held: dec!(100),
                locked: false,
            },
        );
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();
        let mut deposit = make_deposit(1, 1, dec!(100));
        deposit.disputed = true;
        transactions.insert(1, deposit);

        // Client 2 trying to resolve client 1's dispute
        let tx = make_resolve(2, 1);
        let result = handle_resolve(&tx, &mut accounts, &mut transactions);

        assert!(result.is_err());
    }

    // =========================================================================
    // Chargeback Tests
    // =========================================================================

    #[test]
    fn chargeback_removes_held_and_locks_account() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        accounts.insert(
            1,
            AccountRecord {
                available: dec!(50),
                held: dec!(100),
                locked: false,
            },
        );
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();
        let mut deposit = make_deposit(1, 1, dec!(100));
        deposit.disputed = true;
        transactions.insert(1, deposit);

        let tx = make_chargeback(1, 1);
        let result = handle_chargeback(&tx, &mut accounts, &mut transactions);

        assert!(result.is_ok());
        assert_eq!(accounts.get(&1).unwrap().available, dec!(50)); // unchanged
        assert_eq!(accounts.get(&1).unwrap().held, dec!(0));
        assert!(accounts.get(&1).unwrap().locked);
        assert!(!transactions.get(&1).unwrap().disputed);
    }

    #[test]
    fn chargeback_rejects_not_disputed() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        accounts.insert(
            1,
            AccountRecord {
                available: dec!(100),
                held: dec!(0),
                locked: false,
            },
        );
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();
        transactions.insert(1, make_deposit(1, 1, dec!(100)));

        let tx = make_chargeback(1, 1);
        let result = handle_chargeback(&tx, &mut accounts, &mut transactions);

        assert!(result.is_err());
        assert!(!accounts.get(&1).unwrap().locked);
    }

    #[test]
    fn chargeback_rejects_wrong_client() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        accounts.insert(
            1,
            AccountRecord {
                available: dec!(0),
                held: dec!(100),
                locked: false,
            },
        );
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();
        let mut deposit = make_deposit(1, 1, dec!(100));
        deposit.disputed = true;
        transactions.insert(1, deposit);

        // Client 2 trying to chargeback client 1's transaction
        let tx = make_chargeback(2, 1);
        let result = handle_chargeback(&tx, &mut accounts, &mut transactions);

        assert!(result.is_err());
    }

    // =========================================================================
    // Round-trip / Invariant Tests
    // =========================================================================

    #[test]
    fn dispute_then_resolve_restores_original_state() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();

        handle_deposit(
            make_deposit(1, 1, dec!(100)),
            &mut accounts,
            &mut transactions,
        )
        .unwrap();

        let original_available = accounts.get(&1).unwrap().available;
        let original_held = accounts.get(&1).unwrap().held;

        // Dispute then resolve
        handle_dispute(&make_dispute(1, 1), &mut accounts, &mut transactions).unwrap();
        handle_resolve(&make_resolve(1, 1), &mut accounts, &mut transactions).unwrap();

        // Should be back to original
        assert_eq!(accounts.get(&1).unwrap().available, original_available);
        assert_eq!(accounts.get(&1).unwrap().held, original_held);
        assert!(!transactions.get(&1).unwrap().disputed);
    }

    #[test]
    fn total_remains_constant_through_dispute() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();

        handle_deposit(
            make_deposit(1, 1, dec!(100)),
            &mut accounts,
            &mut transactions,
        )
        .unwrap();

        let total_before = accounts.get(&1).unwrap().available + accounts.get(&1).unwrap().held;

        handle_dispute(&make_dispute(1, 1), &mut accounts, &mut transactions).unwrap();

        let total_after = accounts.get(&1).unwrap().available + accounts.get(&1).unwrap().held;

        assert_eq!(
            total_before, total_after,
            "Total should not change during dispute"
        );
    }

    #[test]
    fn total_remains_constant_through_resolve() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();

        handle_deposit(
            make_deposit(1, 1, dec!(100)),
            &mut accounts,
            &mut transactions,
        )
        .unwrap();
        handle_dispute(&make_dispute(1, 1), &mut accounts, &mut transactions).unwrap();

        let total_before = accounts.get(&1).unwrap().available + accounts.get(&1).unwrap().held;

        handle_resolve(&make_resolve(1, 1), &mut accounts, &mut transactions).unwrap();

        let total_after = accounts.get(&1).unwrap().available + accounts.get(&1).unwrap().held;

        assert_eq!(
            total_before, total_after,
            "Total should not change during resolve"
        );
    }

    #[test]
    fn chargeback_reduces_total_by_disputed_amount() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();

        handle_deposit(
            make_deposit(1, 1, dec!(100)),
            &mut accounts,
            &mut transactions,
        )
        .unwrap();
        handle_deposit(
            make_deposit(1, 2, dec!(50)),
            &mut accounts,
            &mut transactions,
        )
        .unwrap();

        let total_before = accounts.get(&1).unwrap().available + accounts.get(&1).unwrap().held;
        assert_eq!(total_before, dec!(150));

        handle_dispute(&make_dispute(1, 1), &mut accounts, &mut transactions).unwrap();
        handle_chargeback(&make_chargeback(1, 1), &mut accounts, &mut transactions).unwrap();

        let total_after = accounts.get(&1).unwrap().available + accounts.get(&1).unwrap().held;

        assert_eq!(
            total_after,
            dec!(50),
            "Total should decrease by chargeback amount (100)"
        );
    }

    #[test]
    fn multiple_deposits_withdrawals_balance_correctly() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();

        handle_deposit(
            make_deposit(1, 1, dec!(100)),
            &mut accounts,
            &mut transactions,
        )
        .unwrap();
        handle_deposit(
            make_deposit(1, 2, dec!(50)),
            &mut accounts,
            &mut transactions,
        )
        .unwrap();
        handle_withdrawal(&make_withdrawal(1, 3, dec!(30)), &mut accounts).unwrap();
        handle_deposit(
            make_deposit(1, 4, dec!(20)),
            &mut accounts,
            &mut transactions,
        )
        .unwrap();
        handle_withdrawal(&make_withdrawal(1, 5, dec!(40)), &mut accounts).unwrap();

        // 100 + 50 - 30 + 20 - 40 = 100
        assert_eq!(accounts.get(&1).unwrap().available, dec!(100));
    }

    #[test]
    fn dispute_resolve_cycle_can_repeat() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();

        handle_deposit(
            make_deposit(1, 1, dec!(100)),
            &mut accounts,
            &mut transactions,
        )
        .unwrap();

        // First cycle
        handle_dispute(&make_dispute(1, 1), &mut accounts, &mut transactions).unwrap();
        assert_eq!(accounts.get(&1).unwrap().held, dec!(100));
        handle_resolve(&make_resolve(1, 1), &mut accounts, &mut transactions).unwrap();
        assert_eq!(accounts.get(&1).unwrap().available, dec!(100));

        // Second cycle - should work again
        handle_dispute(&make_dispute(1, 1), &mut accounts, &mut transactions).unwrap();
        assert_eq!(accounts.get(&1).unwrap().held, dec!(100));
        handle_resolve(&make_resolve(1, 1), &mut accounts, &mut transactions).unwrap();
        assert_eq!(accounts.get(&1).unwrap().available, dec!(100));
    }

    #[test]
    fn failed_operations_dont_change_state() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();

        handle_deposit(
            make_deposit(1, 1, dec!(100)),
            &mut accounts,
            &mut transactions,
        )
        .unwrap();

        let available_before = accounts.get(&1).unwrap().available;
        let held_before = accounts.get(&1).unwrap().held;

        // These should all fail
        let _ = handle_withdrawal(&make_withdrawal(1, 2, dec!(200)), &mut accounts); // insufficient
        let _ = handle_resolve(&make_resolve(1, 1), &mut accounts, &mut transactions); // not disputed
        let _ = handle_chargeback(&make_chargeback(1, 1), &mut accounts, &mut transactions); // not disputed

        // State should be unchanged
        assert_eq!(accounts.get(&1).unwrap().available, available_before);
        assert_eq!(accounts.get(&1).unwrap().held, held_before);
    }

    #[test]
    fn locked_account_blocks_all_deposits_and_withdrawals() {
        let mut accounts: HashMap<u16, AccountRecord> = HashMap::new();
        let mut transactions: HashMap<u32, TransactionRow> = HashMap::new();

        handle_deposit(
            make_deposit(1, 1, dec!(100)),
            &mut accounts,
            &mut transactions,
        )
        .unwrap();
        handle_dispute(&make_dispute(1, 1), &mut accounts, &mut transactions).unwrap();
        handle_chargeback(&make_chargeback(1, 1), &mut accounts, &mut transactions).unwrap();

        assert!(accounts.get(&1).unwrap().locked);
        let available_after_lock = accounts.get(&1).unwrap().available;

        // Both should fail
        let deposit_result = handle_deposit(
            make_deposit(1, 2, dec!(50)),
            &mut accounts,
            &mut transactions,
        );
        let withdrawal_result = handle_withdrawal(&make_withdrawal(1, 3, dec!(10)), &mut accounts);

        assert!(deposit_result.is_err());
        assert!(withdrawal_result.is_err());
        assert_eq!(accounts.get(&1).unwrap().available, available_after_lock);
    }
}
